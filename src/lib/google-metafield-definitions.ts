// Google Shopping Metafield Definitions
// Creates structured metafield definitions for better Shopify admin integration

export interface MetafieldDefinition {
  namespace: string
  key: string
  name: string
  description: string
  type: {
    name: string
    category?: string
    choices?: string[]
  }
  owner_type: 'product' | 'product_variant'
  validations?: Array<{
    name: string
    value: string
  }>
}

// Google Shopping Product Metafield Definitions
export const GOOGLE_PRODUCT_METAFIELD_DEFINITIONS: MetafieldDefinition[] = [
  {
    namespace: 'google',
    key: 'google_product_category',
    name: 'Google Product Category',
    description: 'Google Shopping product category for better search visibility and compliance',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product',
    validations: [
      {
        name: 'max',
        value: '750'
      }
    ]
  },
  {
    namespace: 'google',
    key: 'condition',
    name: 'Condition',
    description: 'Product condition for Google Shopping (new, refurbished, used)',
    type: {
      name: 'single_line_text_field',
      category: 'choices',
      choices: ['new', 'refurbished', 'used']
    },
    owner_type: 'product'
  },
  {
    namespace: 'google',
    key: 'gender',
    name: 'Target Gender',
    description: 'Target gender for the product (male, female, unisex)',
    type: {
      name: 'single_line_text_field',
      category: 'choices',
      choices: ['male', 'female', 'unisex']
    },
    owner_type: 'product'
  },
  {
    namespace: 'google',
    key: 'age_group',
    name: 'Age Group',
    description: 'Target age group for the product',
    type: {
      name: 'single_line_text_field',
      category: 'choices',
      choices: ['newborn', 'infant', 'toddler', 'kids', 'adult']
    },
    owner_type: 'product'
  },
  {
    namespace: 'google',
    key: 'material',
    name: 'Material',
    description: 'Primary material the product is made from',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product'
  },
  {
    namespace: 'google',
    key: 'pattern',
    name: 'Pattern',
    description: 'Pattern or design of the product (solid, striped, floral, etc.)',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product'
  },
  {
    namespace: 'google',
    key: 'size_type',
    name: 'Size Type',
    description: 'Size classification for the product',
    type: {
      name: 'single_line_text_field',
      category: 'choices',
      choices: ['regular', 'petite', 'plus', 'big_and_tall', 'maternity']
    },
    owner_type: 'product'
  },
  {
    namespace: 'google',
    key: 'product_highlights',
    name: 'Product Highlights',
    description: 'Key features and selling points of the product',
    type: {
      name: 'list.single_line_text_field'
    },
    owner_type: 'product'
  }
]

// Google Shopping Variant Metafield Definitions
export const GOOGLE_VARIANT_METAFIELD_DEFINITIONS: MetafieldDefinition[] = [
  {
    namespace: 'google',
    key: 'google_color',
    name: 'Google Color',
    description: 'Color of this specific variant for Google Shopping',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product_variant'
  },
  {
    namespace: 'google',
    key: 'google_size',
    name: 'Google Size',
    description: 'Size of this specific variant for Google Shopping',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product_variant'
  },
  {
    namespace: 'google',
    key: 'google_material',
    name: 'Google Material',
    description: 'Material of this specific variant for Google Shopping',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product_variant'
  }
]

// Thunder Text Metafield Definitions
export const THUNDER_TEXT_METAFIELD_DEFINITIONS: MetafieldDefinition[] = [
  {
    namespace: 'thunder_text',
    key: 'meta_description',
    name: 'Thunder Text Meta Description',
    description: 'SEO meta description generated by Thunder Text AI',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product',
    validations: [
      {
        name: 'max',
        value: '320'
      }
    ]
  },
  {
    namespace: 'thunder_text',
    key: 'keywords',
    name: 'Thunder Text Keywords',
    description: 'SEO keywords generated by Thunder Text AI',
    type: {
      name: 'json'
    },
    owner_type: 'product'
  },
  {
    namespace: 'thunder_text',
    key: 'bullet_points',
    name: 'Thunder Text Bullet Points',
    description: 'Product bullet points generated by Thunder Text AI',
    type: {
      name: 'json'
    },
    owner_type: 'product'
  }
]

// SEO Metafield Definitions
export const SEO_METAFIELD_DEFINITIONS: MetafieldDefinition[] = [
  {
    namespace: 'seo',
    key: 'meta_description',
    name: 'SEO Meta Description',
    description: 'Search engine meta description for better SEO',
    type: {
      name: 'single_line_text_field'
    },
    owner_type: 'product',
    validations: [
      {
        name: 'max',
        value: '320'
      }
    ]
  }
]

// Combined definitions for bulk operations
export const ALL_METAFIELD_DEFINITIONS = [
  ...GOOGLE_PRODUCT_METAFIELD_DEFINITIONS,
  ...GOOGLE_VARIANT_METAFIELD_DEFINITIONS,
  ...THUNDER_TEXT_METAFIELD_DEFINITIONS,
  ...SEO_METAFIELD_DEFINITIONS
]

// Convert to Shopify GraphQL format
export function formatMetafieldDefinitionForShopify(definition: MetafieldDefinition) {
  const baseDefinition = {
    name: definition.name,
    description: definition.description,
    namespace: definition.namespace,
    key: definition.key,
    ownerType: definition.owner_type.toUpperCase(),
    type: definition.type.name,
    validations: definition.validations || []
  }

  // Handle choice-based types
  if (definition.type.category === 'choices' && definition.type.choices) {
    return {
      ...baseDefinition,
      type: 'single_line_text_field',
      validations: [
        ...baseDefinition.validations,
        {
          name: 'choices',
          value: JSON.stringify(definition.type.choices)
        }
      ]
    }
  }

  return baseDefinition
}

// Create all metafield definitions via GraphQL
export async function createMetafieldDefinitions(shopifyClient: any) {
  console.log('🔧 Creating metafield definitions for better admin integration...')
  
  const results = []
  
  for (const definition of ALL_METAFIELD_DEFINITIONS) {
    try {
      const formattedDefinition = formatMetafieldDefinitionForShopify(definition)
      
      const mutation = `
        mutation metafieldDefinitionCreate($definition: MetafieldDefinitionInput!) {
          metafieldDefinitionCreate(definition: $definition) {
            metafieldDefinition {
              id
              name
              namespace
              key
              ownerType
            }
            userErrors {
              field
              message
            }
          }
        }
      `
      
      const response = await shopifyClient.request(mutation, {
        variables: {
          definition: formattedDefinition
        }
      })
      
      if (response.data?.metafieldDefinitionCreate?.userErrors?.length > 0) {
        const errors = response.data.metafieldDefinitionCreate.userErrors
        // Ignore "already exists" errors
        const nonExistenceErrors = errors.filter((error: any) => 
          !error.message.includes('already exists') && 
          !error.message.includes('already taken')
        )
        
        if (nonExistenceErrors.length > 0) {
          console.error(`❌ Error creating definition for ${definition.namespace}.${definition.key}:`, nonExistenceErrors)
        } else {
          console.log(`✅ Definition exists: ${definition.namespace}.${definition.key}`)
        }
      } else {
        console.log(`✅ Created definition: ${definition.namespace}.${definition.key}`)
      }
      
      results.push({
        definition: definition.namespace + '.' + definition.key,
        success: true
      })
      
    } catch (error) {
      console.error(`❌ Failed to create definition for ${definition.namespace}.${definition.key}:`, error)
      results.push({
        definition: definition.namespace + '.' + definition.key,
        success: false,
        error: error
      })
    }
  }
  
  const successful = results.filter(r => r.success).length
  const total = results.length
  
  console.log(`🎯 Metafield definitions: ${successful}/${total} processed`)
  
  return results
}